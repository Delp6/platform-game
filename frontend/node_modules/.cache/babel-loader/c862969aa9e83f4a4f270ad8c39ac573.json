{"ast":null,"code":"var MatchAtDir = function (pattern, startTileX, startTileY, direction) {\n  // pattern: pattern list or repeat count\n  var matchNMode = typeof pattern === 'number';\n  var patternLength;\n\n  if (matchNMode) {\n    patternLength = pattern;\n    pattern = null;\n  } else {\n    patternLength = pattern.length;\n  }\n\n  var symbol,\n      wildcard = this.wildcard;\n  var curTileXY;\n  var board = this.board;\n  var matchedTileXY = result.tileXY;\n  matchedTileXY.length = 0;\n\n  for (var i = 0; i < patternLength; i++) {\n    if (curTileXY === undefined) {\n      curTileXY = {\n        x: startTileX,\n        y: startTileY\n      };\n    } else {\n      // get next tileXY \n      curTileXY = board.getNeighborTileXY(curTileXY, direction, curTileXY);\n\n      if (curTileXY === null) {\n        return false;\n      }\n    }\n\n    symbol = this.getSymbol(curTileXY.x, curTileXY.y);\n\n    if (symbol == null) {\n      return false;\n    }\n\n    if (symbol !== wildcard) {\n      if (matchNMode) {\n        if (pattern === null) {\n          pattern = symbol;\n        } else if (pattern !== symbol) {\n          return false;\n        }\n      } else if (pattern[i] !== symbol) {\n        // pattern list mode\n        return false;\n      }\n    }\n\n    matchedTileXY.push({\n      x: curTileXY.x,\n      y: curTileXY.y\n    });\n  }\n\n  result.direction = direction;\n  result.pattern = pattern;\n  return result;\n};\n\nvar result = {\n  tileXY: [],\n  direction: undefined,\n  pattern: undefined\n};\nexport default MatchAtDir;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/match/MatchAtDir.js"],"names":["MatchAtDir","pattern","startTileX","startTileY","direction","matchNMode","patternLength","length","symbol","wildcard","curTileXY","board","matchedTileXY","result","tileXY","i","undefined","x","y","getNeighborTileXY","getSymbol","push"],"mappings":"AAAA,IAAIA,UAAU,GAAG,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,UAA/B,EAA2CC,SAA3C,EAAsD;AACnE;AACA,MAAIC,UAAU,GAAG,OAAQJ,OAAR,KAAqB,QAAtC;AACA,MAAIK,aAAJ;;AACA,MAAID,UAAJ,EAAgB;AACZC,IAAAA,aAAa,GAAGL,OAAhB;AACAA,IAAAA,OAAO,GAAG,IAAV;AACH,GAHD,MAGO;AACHK,IAAAA,aAAa,GAAGL,OAAO,CAACM,MAAxB;AACH;;AAED,MAAIC,MAAJ;AAAA,MAAYC,QAAQ,GAAG,KAAKA,QAA5B;AACA,MAAIC,SAAJ;AACA,MAAIC,KAAK,GAAG,KAAKA,KAAjB;AACA,MAAIC,aAAa,GAAGC,MAAM,CAACC,MAA3B;AACAF,EAAAA,aAAa,CAACL,MAAd,GAAuB,CAAvB;;AACA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,aAApB,EAAmCS,CAAC,EAApC,EAAwC;AACpC,QAAIL,SAAS,KAAKM,SAAlB,EAA6B;AACzBN,MAAAA,SAAS,GAAG;AACRO,QAAAA,CAAC,EAAEf,UADK;AAERgB,QAAAA,CAAC,EAAEf;AAFK,OAAZ;AAIH,KALD,MAKO;AACH;AACAO,MAAAA,SAAS,GAAGC,KAAK,CAACQ,iBAAN,CAAwBT,SAAxB,EAAmCN,SAAnC,EAA8CM,SAA9C,CAAZ;;AACA,UAAIA,SAAS,KAAK,IAAlB,EAAwB;AACpB,eAAO,KAAP;AACH;AACJ;;AAEDF,IAAAA,MAAM,GAAG,KAAKY,SAAL,CAAeV,SAAS,CAACO,CAAzB,EAA4BP,SAAS,CAACQ,CAAtC,CAAT;;AACA,QAAIV,MAAM,IAAI,IAAd,EAAoB;AAChB,aAAO,KAAP;AACH;;AACD,QAAIA,MAAM,KAAKC,QAAf,EAAyB;AACrB,UAAIJ,UAAJ,EAAgB;AACZ,YAAIJ,OAAO,KAAK,IAAhB,EAAsB;AAClBA,UAAAA,OAAO,GAAGO,MAAV;AACH,SAFD,MAEO,IAAIP,OAAO,KAAKO,MAAhB,EAAwB;AAC3B,iBAAO,KAAP;AACH;AACJ,OAND,MAMO,IAAIP,OAAO,CAACc,CAAD,CAAP,KAAeP,MAAnB,EAA2B;AAAE;AAChC,eAAO,KAAP;AACH;AACJ;;AAEDI,IAAAA,aAAa,CAACS,IAAd,CAAmB;AACfJ,MAAAA,CAAC,EAAEP,SAAS,CAACO,CADE;AAEfC,MAAAA,CAAC,EAAER,SAAS,CAACQ;AAFE,KAAnB;AAIH;;AAEDL,EAAAA,MAAM,CAACT,SAAP,GAAmBA,SAAnB;AACAS,EAAAA,MAAM,CAACZ,OAAP,GAAiBA,OAAjB;AACA,SAAOY,MAAP;AACH,CAvDD;;AAyDA,IAAIA,MAAM,GAAG;AACTC,EAAAA,MAAM,EAAE,EADC;AAETV,EAAAA,SAAS,EAAEY,SAFF;AAGTf,EAAAA,OAAO,EAAEe;AAHA,CAAb;AAKA,eAAehB,UAAf","sourcesContent":["var MatchAtDir = function (pattern, startTileX, startTileY, direction) {\r\n    // pattern: pattern list or repeat count\r\n    var matchNMode = typeof (pattern) === 'number';\r\n    var patternLength;\r\n    if (matchNMode) {\r\n        patternLength = pattern;\r\n        pattern = null;\r\n    } else {\r\n        patternLength = pattern.length;\r\n    }\r\n\r\n    var symbol, wildcard = this.wildcard;\r\n    var curTileXY;\r\n    var board = this.board;\r\n    var matchedTileXY = result.tileXY;\r\n    matchedTileXY.length = 0;\r\n    for (var i = 0; i < patternLength; i++) {\r\n        if (curTileXY === undefined) {\r\n            curTileXY = {\r\n                x: startTileX,\r\n                y: startTileY\r\n            };\r\n        } else {\r\n            // get next tileXY \r\n            curTileXY = board.getNeighborTileXY(curTileXY, direction, curTileXY);\r\n            if (curTileXY === null) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        symbol = this.getSymbol(curTileXY.x, curTileXY.y);\r\n        if (symbol == null) {\r\n            return false;\r\n        }\r\n        if (symbol !== wildcard) {\r\n            if (matchNMode) {\r\n                if (pattern === null) {\r\n                    pattern = symbol;\r\n                } else if (pattern !== symbol) {\r\n                    return false;\r\n                }\r\n            } else if (pattern[i] !== symbol) { // pattern list mode\r\n                return false;\r\n            }\r\n        }\r\n\r\n        matchedTileXY.push({\r\n            x: curTileXY.x,\r\n            y: curTileXY.y\r\n        });\r\n    }\r\n\r\n    result.direction = direction;\r\n    result.pattern = pattern;\r\n    return result;\r\n};\r\n\r\nvar result = {\r\n    tileXY: [],\r\n    direction: undefined,\r\n    pattern: undefined\r\n};\r\nexport default MatchAtDir;"]},"metadata":{},"sourceType":"module"}