{"ast":null,"code":"import GetValue from '../../utils/object/GetValue.js';\n\nvar MoveToTile = function (tileX, tileY, direction) {\n  var board = this.chessData.board;\n\n  if (board === null) {\n    // chess is not in a board\n    this.lastMoveResult = false;\n    return this;\n  }\n\n  if (tileX != null && typeof tileX !== 'number') {\n    var config = tileX;\n    tileX = GetValue(config, 'x', undefined);\n    tileY = GetValue(config, 'y', undefined);\n    direction = GetValue(config, 'direction', undefined);\n  }\n\n  var myTileXYZ = this.chessData.tileXYZ;\n\n  if (direction !== undefined && tileX == null || tileY == null) {\n    // Get neighbor tile position if direction is not undefined\n    var targetTileXY = board.getNeighborTileXY(myTileXYZ, direction, true);\n\n    if (targetTileXY !== null) {\n      tileX = targetTileXY.x;\n      tileY = targetTileXY.y;\n    } else {\n      tileX = null;\n      tileY = null;\n    }\n  } // invalid tile position\n\n\n  if (tileX == null || tileY == null) {\n    this.lastMoveResult = false;\n    return this;\n  }\n\n  if (direction === undefined) {\n    globTileXYZ.x = tileX;\n    globTileXYZ.y = tileY;\n    direction = board.getNeighborTileDirection(myTileXYZ, globTileXYZ);\n  }\n\n  if (!this.canMoveTo(tileX, tileY, direction)) {\n    this.lastMoveResult = false;\n    return this;\n  }\n\n  this.destinationTileX = tileX;\n  this.destinationTileY = tileY;\n  this.destinationDirection = direction;\n\n  if (board.wrapMode && direction !== null) {\n    board.grid.getNeighborTileXY(myTileXYZ.x, myTileXYZ.y, direction, neighborTileXY); // wrap mode && neighbor\n\n    if (neighborTileXY.x === tileX && neighborTileXY.y === tileY) {\n      // not a wrapped neighbor\n      var out = board.tileXYToWorldXY(tileX, tileY, true);\n      this.moveAlongLine(undefined, undefined, out.x, out.y);\n    } else {\n      // wrapped neighbor\n      // line 0\n      var out = board.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, true);\n      var originNeighborWorldX = out.x;\n      var originNeighborWorldY = out.y;\n      out = board.tileXYToWorldXY(myTileXYZ.x, myTileXYZ.y, true);\n      var startX = out.x;\n      var startY = out.y;\n      var endX = (startX + originNeighborWorldX) / 2;\n      var endY = (startY + originNeighborWorldY) / 2;\n      this.moveAlongLine(undefined, undefined, endX, endY); // line 1\n\n      var oppositeDirection = board.getOppositeDirection(tileX, tileY, direction);\n      board.grid.getNeighborTileXY(tileX, tileY, oppositeDirection, neighborTileXY);\n      out = board.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, true);\n      originNeighborWorldX = out.x;\n      originNeighborWorldY = out.y;\n      out = board.tileXYToWorldXY(tileX, tileY, true);\n      endX = out.x;\n      endY = out.y;\n      startX = (originNeighborWorldX + endX) / 2;\n      startY = (originNeighborWorldY + endY) / 2;\n      this.addMoveLine(startX, startY, endX, endY);\n    }\n  } else {\n    var out = board.tileXYToWorldXY(tileX, tileY, true);\n    this.moveAlongLine(undefined, undefined, out.x, out.y);\n  }\n\n  board.moveChess(this.gameObject, tileX, tileY, undefined, false);\n  this.isRunning = true;\n  this.lastMoveResult = true;\n  return this;\n};\n\nvar globTileXYZ = {};\nvar neighborTileXY = {};\nexport default MoveToTile;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/moveto/MoveToTile.js"],"names":["GetValue","MoveToTile","tileX","tileY","direction","board","chessData","lastMoveResult","config","undefined","myTileXYZ","tileXYZ","targetTileXY","getNeighborTileXY","x","y","globTileXYZ","getNeighborTileDirection","canMoveTo","destinationTileX","destinationTileY","destinationDirection","wrapMode","grid","neighborTileXY","out","tileXYToWorldXY","moveAlongLine","originNeighborWorldX","originNeighborWorldY","startX","startY","endX","endY","oppositeDirection","getOppositeDirection","addMoveLine","moveChess","gameObject","isRunning"],"mappings":"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","sourcesContent":["import GetValue from '../../utils/object/GetValue.js';\r\n\r\nvar MoveToTile = function (tileX, tileY, direction) {\r\n    var board = this.chessData.board;\r\n    if (board === null) { // chess is not in a board\r\n        this.lastMoveResult = false;\r\n        return this;\r\n    }\r\n\r\n    if ((tileX != null) && (typeof (tileX) !== 'number')) {\r\n        var config = tileX;\r\n        tileX = GetValue(config, 'x', undefined);\r\n        tileY = GetValue(config, 'y', undefined);\r\n        direction = GetValue(config, 'direction', undefined);\r\n    }\r\n    var myTileXYZ = this.chessData.tileXYZ;\r\n    if ((direction !== undefined) &&\r\n        (tileX == null) || (tileY == null)) {\r\n        // Get neighbor tile position if direction is not undefined\r\n        var targetTileXY = board.getNeighborTileXY(myTileXYZ, direction, true);\r\n        if (targetTileXY !== null) {\r\n            tileX = targetTileXY.x;\r\n            tileY = targetTileXY.y;\r\n        } else {\r\n            tileX = null;\r\n            tileY = null;\r\n        }\r\n    }\r\n\r\n    // invalid tile position\r\n    if ((tileX == null) || (tileY == null)) {\r\n        this.lastMoveResult = false;\r\n        return this;\r\n    }\r\n    if (direction === undefined) {\r\n        globTileXYZ.x = tileX;\r\n        globTileXYZ.y = tileY\r\n        direction = board.getNeighborTileDirection(myTileXYZ, globTileXYZ);\r\n    }\r\n    if (!this.canMoveTo(tileX, tileY, direction)) {\r\n        this.lastMoveResult = false;\r\n        return this;\r\n    }\r\n    this.destinationTileX = tileX;\r\n    this.destinationTileY = tileY;\r\n    this.destinationDirection = direction;\r\n\r\n    if (board.wrapMode && (direction !== null)) {\r\n        board.grid.getNeighborTileXY(myTileXYZ.x, myTileXYZ.y, direction, neighborTileXY);\r\n        // wrap mode && neighbor\r\n        if ((neighborTileXY.x === tileX) && (neighborTileXY.y === tileY)) {\r\n            // not a wrapped neighbor\r\n            var out = board.tileXYToWorldXY(tileX, tileY, true);\r\n            this.moveAlongLine(undefined, undefined, out.x, out.y);\r\n        } else {\r\n            // wrapped neighbor\r\n            // line 0\r\n            var out = board.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, true);\r\n            var originNeighborWorldX = out.x;\r\n            var originNeighborWorldY = out.y;\r\n            out = board.tileXYToWorldXY(myTileXYZ.x, myTileXYZ.y, true);\r\n            var startX = out.x;\r\n            var startY = out.y;\r\n            var endX = (startX + originNeighborWorldX) / 2;\r\n            var endY = (startY + originNeighborWorldY) / 2;\r\n            this.moveAlongLine(undefined, undefined, endX, endY);\r\n            // line 1\r\n            var oppositeDirection = board.getOppositeDirection(tileX, tileY, direction);\r\n            board.grid.getNeighborTileXY(tileX, tileY, oppositeDirection, neighborTileXY);\r\n            out = board.tileXYToWorldXY(neighborTileXY.x, neighborTileXY.y, true);\r\n            originNeighborWorldX = out.x;\r\n            originNeighborWorldY = out.y;\r\n            out = board.tileXYToWorldXY(tileX, tileY, true);\r\n            endX = out.x;\r\n            endY = out.y;\r\n            startX = (originNeighborWorldX + endX) / 2;\r\n            startY = (originNeighborWorldY + endY) / 2;\r\n            this.addMoveLine(startX, startY, endX, endY);\r\n        }\r\n    } else {\r\n        var out = board.tileXYToWorldXY(tileX, tileY, true);\r\n        this.moveAlongLine(undefined, undefined, out.x, out.y);\r\n    }\r\n    board.moveChess(this.gameObject, tileX, tileY, undefined, false);\r\n\r\n    this.isRunning = true;\r\n    this.lastMoveResult = true;\r\n    return this;\r\n}\r\n\r\nvar globTileXYZ = {};\r\nvar neighborTileXY = {};\r\n\r\nexport default MoveToTile;"]},"metadata":{},"sourceType":"module"}