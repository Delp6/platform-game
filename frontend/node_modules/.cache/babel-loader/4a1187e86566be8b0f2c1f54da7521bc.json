{"ast":null,"code":"import Methods from './Methods.js';\nimport IsFunction from '../../utils/object/IsFunction.js';\nimport GetValue from '../../utils/object/GetValue.js';\nimport IsPlainObject from '../../utils/object/IsPlainObject.js';\n\nclass Match {\n  constructor(config) {\n    this.symbols = []; // tileX+(tileY*board.width)\n\n    this.dirMask = {};\n    this.resetFromJSON(config);\n    this.boot();\n  }\n\n  resetFromJSON(o) {\n    this.setBoard(GetValue(o, 'board', undefined));\n    this.setWildcard(GetValue(o, 'wildcard', undefined));\n    var dirMask = GetValue(o, 'dirMask', undefined);\n\n    if (dirMask !== undefined) {\n      this.setDirMask(dirMask);\n    }\n\n    return this;\n  }\n\n  boot() {}\n\n  shutdown() {\n    this.board = undefined;\n    this.symbols = undefined;\n    this.dirMask = undefined;\n    return this;\n  }\n\n  destroy() {\n    this.shutdown();\n    return this;\n  }\n\n  setBoard(board) {\n    this.board = board;\n\n    if (board) {\n      this.clearSymbols();\n    }\n\n    return this;\n  }\n\n  setDirMask(dir, value) {\n    if (IsPlainObject(dir)) {\n      var dirMask = dir;\n\n      for (dir in dirMask) {\n        this.dirMask[dir] = dirMask[dir];\n      }\n    } else {\n      this.dirMask[dir] = value;\n    }\n\n    return this;\n  }\n\n  setDirectionMode(mode) {\n    this.board.grid.setDirectionMode(mode);\n    return this;\n  }\n\n  clearSymbols() {\n    this.refreshSymbols(null);\n    return this;\n  }\n\n  setSymbol(tileX, tileY, symbol) {\n    var board = this.board;\n\n    if (!board.contains(tileX, tileY)) {\n      return this;\n    }\n\n    this.symbols[this.tileXYToKey(tileX, tileY)] = symbol;\n    return this;\n  }\n\n  getSymbol(tileX, tileY) {\n    return this.symbols[this.tileXYToKey(tileX, tileY)];\n  }\n\n  forEach(callback, scope) {\n    var board = this.board;\n    var tileXY, symbol;\n\n    for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\n      symbol = this.symbols[i];\n      tileXY = this.keyToTileXY(i);\n\n      if (scope) {\n        callback.call(scope, tileXY, symbol, board);\n      } else {\n        callback(tileXY, symbol, board);\n      }\n    }\n\n    return this;\n  }\n\n  refreshSymbols(callback, scope) {\n    var board = this.board;\n    var width = board.width,\n        height = board.height;\n    this.symbols.length = width * height;\n    var symbol, tileXY;\n\n    if (IsFunction(callback)) {\n      // Get symbol by callback\n      for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\n        tileXY = this.keyToTileXY(i, true);\n\n        if (scope) {\n          symbol = callback.call(scope, tileXY, board);\n        } else {\n          symbol = callback(tileXY, board);\n        }\n\n        this.symbols[i] = symbol;\n      }\n    } else {\n      // Fill a given symbol\n      symbol = callback;\n\n      for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\n        this.symbols[i] = symbol;\n      }\n    }\n\n    return this;\n  }\n\n  setWildcard(symbol) {\n    this.wildcard = symbol;\n    return this;\n  }\n\n  tileXYToKey(tileX, tileY) {\n    return tileX + tileY * this.board.width;\n  }\n\n  keyToTileXY(key, out) {\n    if (out === undefined) {\n      out = {};\n    } else if (out === true) {\n      out = globTileXY;\n    }\n\n    var width = this.board.width;\n    out.x = key % width;\n    out.y = Math.floor(key / width);\n    return out;\n  }\n\n  anyMatch(pattern) {\n    return this.match(pattern, null, null, true);\n  }\n\n}\n\nvar globTileXY = {\n  x: 0,\n  y: 0\n};\nObject.assign(Match.prototype, Methods);\nexport default Match;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/match/Match.js"],"names":["Methods","IsFunction","GetValue","IsPlainObject","Match","constructor","config","symbols","dirMask","resetFromJSON","boot","o","setBoard","undefined","setWildcard","setDirMask","shutdown","board","destroy","clearSymbols","dir","value","setDirectionMode","mode","grid","refreshSymbols","setSymbol","tileX","tileY","symbol","contains","tileXYToKey","getSymbol","forEach","callback","scope","tileXY","i","cnt","length","keyToTileXY","call","width","height","wildcard","key","out","globTileXY","x","y","Math","floor","anyMatch","pattern","match","Object","assign","prototype"],"mappings":"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","sourcesContent":["import Methods from './Methods.js';\r\nimport IsFunction from '../../utils/object/IsFunction.js';\r\nimport GetValue from '../../utils/object/GetValue.js';\r\nimport IsPlainObject from '../../utils/object/IsPlainObject.js';\r\n\r\nclass Match {\r\n    constructor(config) {\r\n        this.symbols = []; // tileX+(tileY*board.width)\r\n        this.dirMask = {};\r\n        this.resetFromJSON(config);\r\n        this.boot();\r\n    }\r\n\r\n    resetFromJSON(o) {\r\n        this.setBoard(GetValue(o, 'board', undefined));\r\n        this.setWildcard(GetValue(o, 'wildcard', undefined));\r\n\r\n        var dirMask = GetValue(o, 'dirMask', undefined);\r\n        if (dirMask !== undefined) {\r\n            this.setDirMask(dirMask);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    boot() { }\r\n\r\n    shutdown() {\r\n        this.board = undefined;\r\n        this.symbols = undefined;\r\n        this.dirMask = undefined;\r\n        return this;\r\n    }\r\n\r\n    destroy() {\r\n        this.shutdown();\r\n        return this;\r\n    }\r\n\r\n    setBoard(board) {\r\n        this.board = board;\r\n        if (board) {\r\n            this.clearSymbols();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setDirMask(dir, value) {\r\n        if (IsPlainObject(dir)) {\r\n            var dirMask = dir;\r\n            for (dir in dirMask) {\r\n                this.dirMask[dir] = dirMask[dir];\r\n            }\r\n        } else {\r\n            this.dirMask[dir] = value;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setDirectionMode(mode) {\r\n        this.board.grid.setDirectionMode(mode);\r\n        return this;\r\n    }\r\n\r\n    clearSymbols() {\r\n        this.refreshSymbols(null);\r\n        return this;\r\n    }\r\n\r\n    setSymbol(tileX, tileY, symbol) {\r\n        var board = this.board;\r\n        if (!board.contains(tileX, tileY)) {\r\n            return this;\r\n        }\r\n\r\n        this.symbols[this.tileXYToKey(tileX, tileY)] = symbol;\r\n        return this;\r\n    }\r\n\r\n    getSymbol(tileX, tileY) {\r\n        return this.symbols[this.tileXYToKey(tileX, tileY)];\r\n    }\r\n\r\n    forEach(callback, scope) {\r\n        var board = this.board;\r\n        var tileXY, symbol;\r\n        for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n            symbol = this.symbols[i];\r\n            tileXY = this.keyToTileXY(i);\r\n            if (scope) {\r\n                callback.call(scope, tileXY, symbol, board);\r\n            } else {\r\n                callback(tileXY, symbol, board);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    refreshSymbols(callback, scope) {\r\n        var board = this.board;\r\n        var width = board.width,\r\n            height = board.height;\r\n        this.symbols.length = width * height;\r\n\r\n        var symbol, tileXY;\r\n        if (IsFunction(callback)) {\r\n            // Get symbol by callback\r\n            for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n                tileXY = this.keyToTileXY(i, true);\r\n                if (scope) {\r\n                    symbol = callback.call(scope, tileXY, board);\r\n                } else {\r\n                    symbol = callback(tileXY, board);\r\n                }\r\n                this.symbols[i] = symbol;\r\n            }\r\n\r\n        } else {\r\n            // Fill a given symbol\r\n            symbol = callback;\r\n            for (var i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n                this.symbols[i] = symbol;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setWildcard(symbol) {\r\n        this.wildcard = symbol;\r\n        return this;\r\n    }\r\n\r\n    tileXYToKey(tileX, tileY) {\r\n        return tileX + (tileY * this.board.width);\r\n    }\r\n\r\n    keyToTileXY(key, out) {\r\n        if (out === undefined) {\r\n            out = {};\r\n        } else if (out === true) {\r\n            out = globTileXY;\r\n        }\r\n        var width = this.board.width;\r\n        out.x = key % width;\r\n        out.y = Math.floor(key / width);\r\n        return out;\r\n    }\r\n\r\n    anyMatch(pattern) {\r\n        return this.match(pattern, null, null, true);\r\n    }\r\n}\r\n\r\nvar globTileXY = {\r\n    x: 0,\r\n    y: 0\r\n};\r\n\r\nObject.assign(\r\n    Match.prototype,\r\n    Methods\r\n);\r\n\r\nexport default Match;"]},"metadata":{},"sourceType":"module"}