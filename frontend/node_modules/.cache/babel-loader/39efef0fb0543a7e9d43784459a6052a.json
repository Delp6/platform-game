{"ast":null,"code":"class BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  clear() {\n    this.content.length = 0;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to sink down.\n\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n\n    return result;\n  }\n\n  remove(node) {\n    var i = this.content.indexOf(node); // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  rescoreElement(node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n]; // When at 0, an element can not sink any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = (n + 1 >> 1) - 1,\n          parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN;\n      } // Found a parent that is less, no need to sink any further.\n      else {\n          break;\n        }\n    }\n  }\n\n  bubbleUp(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = n + 1 << 1,\n          child1N = child2N - 1; // This is used to store the new position of the element, if any.\n\n      var swap = null,\n          child1Score; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } // Otherwise, we are done.\n      else {\n          break;\n        }\n    }\n  }\n\n}\n\nexport default BinaryHeap;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/pathfinder/astartsearch/BinaryHeap.js"],"names":["BinaryHeap","constructor","scoreFunction","content","clear","length","push","element","sinkDown","pop","result","end","bubbleUp","remove","node","i","indexOf","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","child1","child2","child2Score"],"mappings":"AAAA,MAAMA,UAAN,CAAiB;AACbC,EAAAA,WAAW,CAACC,aAAD,EAAgB;AACvB,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKD,aAAL,GAAqBA,aAArB;AACH;;AAEDE,EAAAA,KAAK,GAAG;AACJ,SAAKD,OAAL,CAAaE,MAAb,GAAsB,CAAtB;AACH;;AAEDC,EAAAA,IAAI,CAACC,OAAD,EAAU;AACV;AACA,SAAKJ,OAAL,CAAaG,IAAb,CAAkBC,OAAlB,EAFU,CAIV;;AACA,SAAKC,QAAL,CAAc,KAAKL,OAAL,CAAaE,MAAb,GAAsB,CAApC;AACH;;AAEDI,EAAAA,GAAG,GAAG;AACF;AACA,QAAIC,MAAM,GAAG,KAAKP,OAAL,CAAa,CAAb,CAAb,CAFE,CAGF;;AACA,QAAIQ,GAAG,GAAG,KAAKR,OAAL,CAAaM,GAAb,EAAV,CAJE,CAKF;AACA;;AACA,QAAI,KAAKN,OAAL,CAAaE,MAAb,GAAsB,CAA1B,EAA6B;AACzB,WAAKF,OAAL,CAAa,CAAb,IAAkBQ,GAAlB;AACA,WAAKC,QAAL,CAAc,CAAd;AACH;;AACD,WAAOF,MAAP;AACH;;AAEDG,EAAAA,MAAM,CAACC,IAAD,EAAO;AACT,QAAIC,CAAC,GAAG,KAAKZ,OAAL,CAAaa,OAAb,CAAqBF,IAArB,CAAR,CADS,CAGT;AACA;;AACA,QAAIH,GAAG,GAAG,KAAKR,OAAL,CAAaM,GAAb,EAAV;;AAEA,QAAIM,CAAC,KAAK,KAAKZ,OAAL,CAAaE,MAAb,GAAsB,CAAhC,EAAmC;AAC/B,WAAKF,OAAL,CAAaY,CAAb,IAAkBJ,GAAlB;;AAEA,UAAI,KAAKT,aAAL,CAAmBS,GAAnB,IAA0B,KAAKT,aAAL,CAAmBY,IAAnB,CAA9B,EAAwD;AACpD,aAAKN,QAAL,CAAcO,CAAd;AACH,OAFD,MAEO;AACH,aAAKH,QAAL,CAAcG,CAAd;AACH;AACJ;AACJ;;AAEDE,EAAAA,IAAI,GAAG;AACH,WAAO,KAAKd,OAAL,CAAaE,MAApB;AACH;;AAEDa,EAAAA,cAAc,CAACJ,IAAD,EAAO;AACjB,SAAKN,QAAL,CAAc,KAAKL,OAAL,CAAaa,OAAb,CAAqBF,IAArB,CAAd;AACH;;AAEDN,EAAAA,QAAQ,CAACW,CAAD,EAAI;AACR;AACA,QAAIZ,OAAO,GAAG,KAAKJ,OAAL,CAAagB,CAAb,CAAd,CAFQ,CAIR;;AACA,WAAOA,CAAC,GAAG,CAAX,EAAc;AAEV;AACA,UAAIC,OAAO,GAAG,CAAED,CAAC,GAAG,CAAL,IAAW,CAAZ,IAAiB,CAA/B;AAAA,UACIE,MAAM,GAAG,KAAKlB,OAAL,CAAaiB,OAAb,CADb,CAHU,CAKV;;AACA,UAAI,KAAKlB,aAAL,CAAmBK,OAAnB,IAA8B,KAAKL,aAAL,CAAmBmB,MAAnB,CAAlC,EAA8D;AAC1D,aAAKlB,OAAL,CAAaiB,OAAb,IAAwBb,OAAxB;AACA,aAAKJ,OAAL,CAAagB,CAAb,IAAkBE,MAAlB,CAF0D,CAG1D;;AACAF,QAAAA,CAAC,GAAGC,OAAJ;AACH,OALD,CAMA;AANA,WAOK;AACD;AACH;AACJ;AACJ;;AAEDR,EAAAA,QAAQ,CAACO,CAAD,EAAI;AACR;AACA,QAAId,MAAM,GAAG,KAAKF,OAAL,CAAaE,MAA1B;AAAA,QACIE,OAAO,GAAG,KAAKJ,OAAL,CAAagB,CAAb,CADd;AAAA,QAEIG,SAAS,GAAG,KAAKpB,aAAL,CAAmBK,OAAnB,CAFhB;;AAIA,WAAO,IAAP,EAAa;AACT;AACA,UAAIgB,OAAO,GAAIJ,CAAC,GAAG,CAAL,IAAW,CAAzB;AAAA,UACIK,OAAO,GAAGD,OAAO,GAAG,CADxB,CAFS,CAIT;;AACA,UAAIE,IAAI,GAAG,IAAX;AAAA,UACIC,WADJ,CALS,CAOT;;AACA,UAAIF,OAAO,GAAGnB,MAAd,EAAsB;AAClB;AACA,YAAIsB,MAAM,GAAG,KAAKxB,OAAL,CAAaqB,OAAb,CAAb;AACAE,QAAAA,WAAW,GAAG,KAAKxB,aAAL,CAAmByB,MAAnB,CAAd,CAHkB,CAKlB;;AACA,YAAID,WAAW,GAAGJ,SAAlB,EAA6B;AACzBG,UAAAA,IAAI,GAAGD,OAAP;AACH;AACJ,OAjBQ,CAmBT;;;AACA,UAAID,OAAO,GAAGlB,MAAd,EAAsB;AAClB,YAAIuB,MAAM,GAAG,KAAKzB,OAAL,CAAaoB,OAAb,CAAb;AAAA,YACIM,WAAW,GAAG,KAAK3B,aAAL,CAAmB0B,MAAnB,CADlB;;AAEA,YAAIC,WAAW,IAAIJ,IAAI,KAAK,IAAT,GAAgBH,SAAhB,GAA4BI,WAAhC,CAAf,EAA6D;AACzDD,UAAAA,IAAI,GAAGF,OAAP;AACH;AACJ,OA1BQ,CA4BT;;;AACA,UAAIE,IAAI,KAAK,IAAb,EAAmB;AACf,aAAKtB,OAAL,CAAagB,CAAb,IAAkB,KAAKhB,OAAL,CAAasB,IAAb,CAAlB;AACA,aAAKtB,OAAL,CAAasB,IAAb,IAAqBlB,OAArB;AACAY,QAAAA,CAAC,GAAGM,IAAJ;AACH,OAJD,CAKA;AALA,WAMK;AACD;AACH;AACJ;AACJ;;AA/HY;;AAiIjB,eAAezB,UAAf","sourcesContent":["class BinaryHeap {\r\n    constructor(scoreFunction) {\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n    }\r\n\r\n    clear() {\r\n        this.content.length = 0;\r\n    }\r\n\r\n    push(element) {\r\n        // Add the new element to the end of the array.\r\n        this.content.push(element);\r\n\r\n        // Allow it to sink down.\r\n        this.sinkDown(this.content.length - 1);\r\n    }\r\n\r\n    pop() {\r\n        // Store the first element so we can return it later.\r\n        var result = this.content[0];\r\n        // Get the element at the end of the array.\r\n        var end = this.content.pop();\r\n        // If there are any elements left, put the end element at the\r\n        // start, and let it bubble up.\r\n        if (this.content.length > 0) {\r\n            this.content[0] = end;\r\n            this.bubbleUp(0);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    remove(node) {\r\n        var i = this.content.indexOf(node);\r\n\r\n        // When it is found, the process seen in 'pop' is repeated\r\n        // to fill up the hole.\r\n        var end = this.content.pop();\r\n\r\n        if (i !== this.content.length - 1) {\r\n            this.content[i] = end;\r\n\r\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n                this.sinkDown(i);\r\n            } else {\r\n                this.bubbleUp(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    size() {\r\n        return this.content.length;\r\n    }\r\n\r\n    rescoreElement(node) {\r\n        this.sinkDown(this.content.indexOf(node));\r\n    }\r\n\r\n    sinkDown(n) {\r\n        // Fetch the element that has to be sunk.\r\n        var element = this.content[n];\r\n\r\n        // When at 0, an element can not sink any further.\r\n        while (n > 0) {\r\n\r\n            // Compute the parent element's index, and fetch it.\r\n            var parentN = ((n + 1) >> 1) - 1,\r\n                parent = this.content[parentN];\r\n            // Swap the elements if the parent is greater.\r\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n                this.content[parentN] = element;\r\n                this.content[n] = parent;\r\n                // Update 'n' to continue at the new position.\r\n                n = parentN;\r\n            }\r\n            // Found a parent that is less, no need to sink any further.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    bubbleUp(n) {\r\n        // Look up the target element and its score.\r\n        var length = this.content.length,\r\n            element = this.content[n],\r\n            elemScore = this.scoreFunction(element);\r\n\r\n        while (true) {\r\n            // Compute the indices of the child elements.\r\n            var child2N = (n + 1) << 1,\r\n                child1N = child2N - 1;\r\n            // This is used to store the new position of the element, if any.\r\n            var swap = null,\r\n                child1Score;\r\n            // If the first child exists (is inside the array)...\r\n            if (child1N < length) {\r\n                // Look it up and compute its score.\r\n                var child1 = this.content[child1N];\r\n                child1Score = this.scoreFunction(child1);\r\n\r\n                // If the score is less than our element's, we need to swap.\r\n                if (child1Score < elemScore) {\r\n                    swap = child1N;\r\n                }\r\n            }\r\n\r\n            // Do the same checks for the other child.\r\n            if (child2N < length) {\r\n                var child2 = this.content[child2N],\r\n                    child2Score = this.scoreFunction(child2);\r\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n                    swap = child2N;\r\n                }\r\n            }\r\n\r\n            // If the element needs to be moved, swap it, and continue.\r\n            if (swap !== null) {\r\n                this.content[n] = this.content[swap];\r\n                this.content[swap] = element;\r\n                n = swap;\r\n            }\r\n            // Otherwise, we are done.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nexport default BinaryHeap;"]},"metadata":{},"sourceType":"module"}