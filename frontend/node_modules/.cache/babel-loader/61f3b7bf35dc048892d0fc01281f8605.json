{"ast":null,"code":"/* \r\n\r\njavascript-astar 0.3.0\r\nhttp://github.com/bgrins/javascript-astar\r\nFreely distributable under the MIT License.\r\nImplements the astar search algorithm in javascript using a Binary Heap.\r\nIncludes Binary Heap (with modifications) from Marijn Haverbeke.\r\nhttp://eloquentjavascript.net/appendix2.html\r\n\r\n*/\nimport NodeManager from './NodeManager.js';\nimport BinaryHeap from './BinaryHeap.js';\nimport CONST from '../const.js';\nconst AREA_MODE = CONST.AREA_MODE;\nconst PATH_MODE = CONST.PATH_MODE;\nconst ASTAR = CONST['A*'];\nconst ASTAR_LINE = CONST['A*-line'];\nconst ASTAR_RANDOM = CONST['A*-random'];\nconst BLOCKER = CONST.BLOCKER;\nconst INFINITY = CONST.INFINITY; // global object\n\nvar gOpenHeap = new BinaryHeap(function (node) {\n  return node.f;\n}); // global object\n\nvar AStarSerach = function (startTileXYZ, endTileXY, movingPoints, mode) {\n  if (this.nodeManager === undefined) {\n    this.nodeManager = new NodeManager(this);\n  }\n\n  var nodeManager = this.nodeManager;\n  nodeManager.freeAllNodes(); // const isAreaSearch = (mode === AREA_MODE);\n\n  const isPathSearch = mode === PATH_MODE;\n  const isAStarMode = this.pathMode === ASTAR || this.pathMode === ASTAR_LINE || this.pathMode === ASTAR_RANDOM;\n  const astarHeuristicEnable = isPathSearch && isAStarMode;\n  const shortestPathEnable = isPathSearch && !isAStarMode;\n  const astarHeuristicMode = !astarHeuristicEnable ? null : this.pathMode == ASTAR ? 0 : this.pathMode == ASTAR_LINE ? 1 : this.pathMode == ASTAR_RANDOM ? 2 : null;\n  var end = endTileXY !== null ? nodeManager.getNode(endTileXY.x, endTileXY.y, true) : null;\n  var start = nodeManager.getNode(startTileXYZ.x, startTileXYZ.y, true);\n  start.h = start.heuristic(end, astarHeuristicMode); // NEAREST NODE\n\n  var closestNode;\n\n  if (isPathSearch) {\n    closestNode = start;\n    closestNode.closerH = closestNode.h || closestNode.heuristic(end, 0);\n  } // NEAREST NODE\n\n\n  gOpenHeap.push(start);\n\n  while (gOpenHeap.size() > 0) {\n    // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n    var curNode = gOpenHeap.pop(); // End case -- result has been found, return the traced path.\n\n    if (isPathSearch && curNode === end) {\n      closestNode = end;\n      break;\n    } // Normal case -- move curNode from open to closed, process each of its neighbors.\n\n\n    curNode.closed = true; // Find all neighbors for the current node.\n\n    var neighbors = curNode.getNeighborNodes();\n    var neighbor, neighborCost, isNeighborMoreCloser;\n\n    for (var i = 0, cnt = neighbors.length; i < cnt; ++i) {\n      neighbor = neighbors[i];\n      neighborCost = neighbor.getCost(curNode);\n\n      if (neighbor.closed || neighborCost === BLOCKER) {\n        // Not a valid node to process, skip to next neighbor.\n        //log(\"(\"+neighbor.x+\",\"+neighbor.y+\") is closed\");\n        continue;\n      } // The g score is the shortest distance from start to current node.\n      // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n\n\n      var gScore = curNode.g + neighborCost,\n          beenVisited = neighbor.visited; //log(\"(\"+curNode.x+\",\"+curNode.y+\") -> (\"+neighbor.x+\",\"+neighbor.y+\")=\"+neighborCost+\" ,acc=\"+gScore);\n\n      if (movingPoints != INFINITY && gScore > movingPoints) {\n        //log(\"(\"+neighbor.x+\",\"+neighbor.y+\") out of range\");\n        continue;\n      }\n\n      if (!beenVisited || gScore < neighbor.g) {\n        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n        neighbor.visited = true;\n        neighbor.preNodes.length = 0;\n        neighbor.preNodes.push(curNode);\n        neighbor.h = neighbor.h || neighbor.heuristic(end, astarHeuristicMode, start);\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h; // NEAREST NODE\n\n        if (isPathSearch) {\n          neighbor.closerH = neighbor.h || neighbor.heuristic(end, 0);\n          isNeighborMoreCloser = neighbor.closerH < closestNode.closerH || neighbor.closerH === closestNode.closerH && neighbor.g < closestNode.g;\n\n          if (isNeighborMoreCloser) {\n            closestNode = neighbor;\n          }\n        } // NEAREST NODE\n\n\n        if (!beenVisited) {\n          // Pushing to heap will put it in proper place based on the 'f' value.\n          gOpenHeap.push(neighbor); //log(\"push (\"+neighbor.x+\",\"+neighbor.y+\") \")\n        } else {\n          // Already seen the node, but since it has been rescored we need to reorder it in the heap\n          gOpenHeap.rescoreElement(neighbor); //log(\"reorder (\"+neighbor.x+\",\"+neighbor.y+\") \")\n        }\n      } else if (shortestPathEnable && gScore == neighbor.g) {\n        neighbor.preNodes.push(curNode); //if (neighbor.preNodes.indexOf(curNode) == -1)                    \n        //    neighbor.preNodes.push(curNode);                    \n        //else                    \n        //    debugger;                 \n        //log(\"drop (\"+neighbor.x+\",\"+neighbor.y+\") \")                \n      } else {//log(\"drop (\"+neighbor.x+\",\"+neighbor.y+\") \")       \n        }\n    }\n  }\n\n  nodeManager.closestNode = isPathSearch ? closestNode : null;\n  gOpenHeap.clear();\n  return this;\n};\n\nexport default AStarSerach;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/pathfinder/astartsearch/AStarSearch.js"],"names":["NodeManager","BinaryHeap","CONST","AREA_MODE","PATH_MODE","ASTAR","ASTAR_LINE","ASTAR_RANDOM","BLOCKER","INFINITY","gOpenHeap","node","f","AStarSerach","startTileXYZ","endTileXY","movingPoints","mode","nodeManager","undefined","freeAllNodes","isPathSearch","isAStarMode","pathMode","astarHeuristicEnable","shortestPathEnable","astarHeuristicMode","end","getNode","x","y","start","h","heuristic","closestNode","closerH","push","size","curNode","pop","closed","neighbors","getNeighborNodes","neighbor","neighborCost","isNeighborMoreCloser","i","cnt","length","getCost","gScore","g","beenVisited","visited","preNodes","rescoreElement","clear"],"mappings":"AAAA;;;;;;;;;;AAWA,OAAOA,WAAP,MAAwB,kBAAxB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,aAAlB;AAEA,MAAMC,SAAS,GAAGD,KAAK,CAACC,SAAxB;AACA,MAAMC,SAAS,GAAGF,KAAK,CAACE,SAAxB;AAEA,MAAMC,KAAK,GAAGH,KAAK,CAAC,IAAD,CAAnB;AACA,MAAMI,UAAU,GAAGJ,KAAK,CAAC,SAAD,CAAxB;AACA,MAAMK,YAAY,GAAGL,KAAK,CAAC,WAAD,CAA1B;AAEA,MAAMM,OAAO,GAAGN,KAAK,CAACM,OAAtB;AACA,MAAMC,QAAQ,GAAGP,KAAK,CAACO,QAAvB,C,CAEA;;AACA,IAAIC,SAAS,GAAG,IAAIT,UAAJ,CAAe,UAAUU,IAAV,EAAgB;AAC3C,SAAOA,IAAI,CAACC,CAAZ;AACH,CAFe,CAAhB,C,CAGA;;AAEA,IAAIC,WAAW,GAAG,UAAUC,YAAV,EAAwBC,SAAxB,EAAmCC,YAAnC,EAAiDC,IAAjD,EAAuD;AACrE,MAAI,KAAKC,WAAL,KAAqBC,SAAzB,EAAoC;AAChC,SAAKD,WAAL,GAAmB,IAAIlB,WAAJ,CAAgB,IAAhB,CAAnB;AACH;;AACD,MAAIkB,WAAW,GAAG,KAAKA,WAAvB;AACAA,EAAAA,WAAW,CAACE,YAAZ,GALqE,CAOrE;;AACA,QAAMC,YAAY,GAAIJ,IAAI,KAAKb,SAA/B;AACA,QAAMkB,WAAW,GAAI,KAAKC,QAAL,KAAkBlB,KAAnB,IAA8B,KAAKkB,QAAL,KAAkBjB,UAAhD,IAAgE,KAAKiB,QAAL,KAAkBhB,YAAtG;AACA,QAAMiB,oBAAoB,GAAGH,YAAY,IAAIC,WAA7C;AACA,QAAMG,kBAAkB,GAAGJ,YAAY,IAAK,CAACC,WAA7C;AACA,QAAMI,kBAAkB,GACnB,CAACF,oBAAF,GAA0B,IAA1B,GACK,KAAKD,QAAL,IAAiBlB,KAAlB,GAA2B,CAA3B,GACK,KAAKkB,QAAL,IAAiBjB,UAAlB,GAAgC,CAAhC,GACK,KAAKiB,QAAL,IAAiBhB,YAAlB,GAAkC,CAAlC,GACI,IALpB;AAOA,MAAIoB,GAAG,GAAIZ,SAAS,KAAK,IAAf,GAAuBG,WAAW,CAACU,OAAZ,CAAoBb,SAAS,CAACc,CAA9B,EAAiCd,SAAS,CAACe,CAA3C,EAA8C,IAA9C,CAAvB,GAA6E,IAAvF;AACA,MAAIC,KAAK,GAAGb,WAAW,CAACU,OAAZ,CAAoBd,YAAY,CAACe,CAAjC,EAAoCf,YAAY,CAACgB,CAAjD,EAAoD,IAApD,CAAZ;AACAC,EAAAA,KAAK,CAACC,CAAN,GAAUD,KAAK,CAACE,SAAN,CAAgBN,GAAhB,EAAqBD,kBAArB,CAAV,CArBqE,CAuBrE;;AACA,MAAIQ,WAAJ;;AACA,MAAIb,YAAJ,EAAkB;AACda,IAAAA,WAAW,GAAGH,KAAd;AACAG,IAAAA,WAAW,CAACC,OAAZ,GAAsBD,WAAW,CAACF,CAAZ,IAAiBE,WAAW,CAACD,SAAZ,CAAsBN,GAAtB,EAA2B,CAA3B,CAAvC;AACH,GA5BoE,CA6BrE;;;AAEAjB,EAAAA,SAAS,CAAC0B,IAAV,CAAeL,KAAf;;AACA,SAAOrB,SAAS,CAAC2B,IAAV,KAAmB,CAA1B,EAA6B;AACzB;AACA,QAAIC,OAAO,GAAG5B,SAAS,CAAC6B,GAAV,EAAd,CAFyB,CAIzB;;AACA,QAAIlB,YAAY,IAAKiB,OAAO,KAAKX,GAAjC,EAAuC;AACnCO,MAAAA,WAAW,GAAGP,GAAd;AACA;AACH,KARwB,CAUzB;;;AACAW,IAAAA,OAAO,CAACE,MAAR,GAAiB,IAAjB,CAXyB,CAazB;;AACA,QAAIC,SAAS,GAAGH,OAAO,CAACI,gBAAR,EAAhB;AAEA,QAAIC,QAAJ,EAAcC,YAAd,EAA4BC,oBAA5B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGN,SAAS,CAACO,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiD,EAAED,CAAnD,EAAsD;AAClDH,MAAAA,QAAQ,GAAGF,SAAS,CAACK,CAAD,CAApB;AACAF,MAAAA,YAAY,GAAGD,QAAQ,CAACM,OAAT,CAAiBX,OAAjB,CAAf;;AACA,UAAIK,QAAQ,CAACH,MAAT,IAAoBI,YAAY,KAAKpC,OAAzC,EAAmD;AAC/C;AACA;AACA;AACH,OAPiD,CASlD;AACA;;;AACA,UAAI0C,MAAM,GAAGZ,OAAO,CAACa,CAAR,GAAYP,YAAzB;AAAA,UACIQ,WAAW,GAAGT,QAAQ,CAACU,OAD3B,CAXkD,CAclD;;AACA,UAAKrC,YAAY,IAAIP,QAAjB,IAA+ByC,MAAM,GAAGlC,YAA5C,EAA2D;AACvD;AACA;AACH;;AAED,UAAK,CAACoC,WAAF,IAAmBF,MAAM,GAAGP,QAAQ,CAACQ,CAAzC,EAA6C;AAEzC;AACAR,QAAAA,QAAQ,CAACU,OAAT,GAAmB,IAAnB;AACAV,QAAAA,QAAQ,CAACW,QAAT,CAAkBN,MAAlB,GAA2B,CAA3B;AACAL,QAAAA,QAAQ,CAACW,QAAT,CAAkBlB,IAAlB,CAAuBE,OAAvB;AACAK,QAAAA,QAAQ,CAACX,CAAT,GAAaW,QAAQ,CAACX,CAAT,IAAcW,QAAQ,CAACV,SAAT,CAAmBN,GAAnB,EAAwBD,kBAAxB,EAA4CK,KAA5C,CAA3B;AACAY,QAAAA,QAAQ,CAACQ,CAAT,GAAaD,MAAb;AACAP,QAAAA,QAAQ,CAAC/B,CAAT,GAAa+B,QAAQ,CAACQ,CAAT,GAAaR,QAAQ,CAACX,CAAnC,CARyC,CAUzC;;AACA,YAAIX,YAAJ,EAAkB;AACdsB,UAAAA,QAAQ,CAACR,OAAT,GAAmBQ,QAAQ,CAACX,CAAT,IAAcW,QAAQ,CAACV,SAAT,CAAmBN,GAAnB,EAAwB,CAAxB,CAAjC;AACAkB,UAAAA,oBAAoB,GAAIF,QAAQ,CAACR,OAAT,GAAmBD,WAAW,CAACC,OAAhC,IACjBQ,QAAQ,CAACR,OAAT,KAAqBD,WAAW,CAACC,OAAlC,IAA+CQ,QAAQ,CAACQ,CAAT,GAAajB,WAAW,CAACiB,CAD7E;;AAGA,cAAIN,oBAAJ,EAA0B;AACtBX,YAAAA,WAAW,GAAGS,QAAd;AACH;AACJ,SAnBwC,CAoBzC;;;AAEA,YAAI,CAACS,WAAL,EAAkB;AACd;AACA1C,UAAAA,SAAS,CAAC0B,IAAV,CAAeO,QAAf,EAFc,CAGd;AACH,SAJD,MAIO;AACH;AACAjC,UAAAA,SAAS,CAAC6C,cAAV,CAAyBZ,QAAzB,EAFG,CAGH;AACH;AACJ,OA/BD,MA+BO,IAAIlB,kBAAkB,IAAKyB,MAAM,IAAIP,QAAQ,CAACQ,CAA9C,EAAkD;AACrDR,QAAAA,QAAQ,CAACW,QAAT,CAAkBlB,IAAlB,CAAuBE,OAAvB,EADqD,CAGrD;AACA;AACA;AACA;AAEA;AACH,OATM,MASA,CACH;AACH;AACJ;AAEJ;;AAEDpB,EAAAA,WAAW,CAACgB,WAAZ,GAA2Bb,YAAD,GAAiBa,WAAjB,GAA+B,IAAzD;AACAxB,EAAAA,SAAS,CAAC8C,KAAV;AACA,SAAO,IAAP;AACH,CAvHD;;AAwHA,eAAe3C,WAAf","sourcesContent":["/* \r\n\r\njavascript-astar 0.3.0\r\nhttp://github.com/bgrins/javascript-astar\r\nFreely distributable under the MIT License.\r\nImplements the astar search algorithm in javascript using a Binary Heap.\r\nIncludes Binary Heap (with modifications) from Marijn Haverbeke.\r\nhttp://eloquentjavascript.net/appendix2.html\r\n\r\n*/\r\n\r\nimport NodeManager from './NodeManager.js';\r\nimport BinaryHeap from './BinaryHeap.js';\r\nimport CONST from '../const.js';\r\n\r\nconst AREA_MODE = CONST.AREA_MODE;\r\nconst PATH_MODE = CONST.PATH_MODE;\r\n\r\nconst ASTAR = CONST['A*'];\r\nconst ASTAR_LINE = CONST['A*-line'];\r\nconst ASTAR_RANDOM = CONST['A*-random'];\r\n\r\nconst BLOCKER = CONST.BLOCKER;\r\nconst INFINITY = CONST.INFINITY;\r\n\r\n// global object\r\nvar gOpenHeap = new BinaryHeap(function (node) {\r\n    return node.f;\r\n});\r\n// global object\r\n\r\nvar AStarSerach = function (startTileXYZ, endTileXY, movingPoints, mode) {\r\n    if (this.nodeManager === undefined) {\r\n        this.nodeManager = new NodeManager(this);\r\n    }\r\n    var nodeManager = this.nodeManager;\r\n    nodeManager.freeAllNodes();\r\n\r\n    // const isAreaSearch = (mode === AREA_MODE);\r\n    const isPathSearch = (mode === PATH_MODE);\r\n    const isAStarMode = (this.pathMode === ASTAR) || (this.pathMode === ASTAR_LINE) || (this.pathMode === ASTAR_RANDOM);\r\n    const astarHeuristicEnable = isPathSearch && isAStarMode;\r\n    const shortestPathEnable = isPathSearch && (!isAStarMode);\r\n    const astarHeuristicMode =\r\n        (!astarHeuristicEnable) ? null :\r\n            (this.pathMode == ASTAR) ? 0 :\r\n                (this.pathMode == ASTAR_LINE) ? 1 :\r\n                    (this.pathMode == ASTAR_RANDOM) ? 2 :\r\n                        null;\r\n\r\n    var end = (endTileXY !== null) ? nodeManager.getNode(endTileXY.x, endTileXY.y, true) : null;\r\n    var start = nodeManager.getNode(startTileXYZ.x, startTileXYZ.y, true);\r\n    start.h = start.heuristic(end, astarHeuristicMode);\r\n\r\n    // NEAREST NODE\r\n    var closestNode;\r\n    if (isPathSearch) {\r\n        closestNode = start;\r\n        closestNode.closerH = closestNode.h || closestNode.heuristic(end, 0);\r\n    }\r\n    // NEAREST NODE\r\n\r\n    gOpenHeap.push(start);\r\n    while (gOpenHeap.size() > 0) {\r\n        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n        var curNode = gOpenHeap.pop();\r\n\r\n        // End case -- result has been found, return the traced path.\r\n        if (isPathSearch && (curNode === end)) {\r\n            closestNode = end;\r\n            break;\r\n        }\r\n\r\n        // Normal case -- move curNode from open to closed, process each of its neighbors.\r\n        curNode.closed = true;\r\n\r\n        // Find all neighbors for the current node.\r\n        var neighbors = curNode.getNeighborNodes();\r\n\r\n        var neighbor, neighborCost, isNeighborMoreCloser;\r\n        for (var i = 0, cnt = neighbors.length; i < cnt; ++i) {\r\n            neighbor = neighbors[i];\r\n            neighborCost = neighbor.getCost(curNode);\r\n            if (neighbor.closed || (neighborCost === BLOCKER)) {\r\n                // Not a valid node to process, skip to next neighbor.\r\n                //log(\"(\"+neighbor.x+\",\"+neighbor.y+\") is closed\");\r\n                continue;\r\n            }\r\n\r\n            // The g score is the shortest distance from start to current node.\r\n            // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\r\n            var gScore = curNode.g + neighborCost,\r\n                beenVisited = neighbor.visited;\r\n\r\n            //log(\"(\"+curNode.x+\",\"+curNode.y+\") -> (\"+neighbor.x+\",\"+neighbor.y+\")=\"+neighborCost+\" ,acc=\"+gScore);\r\n            if ((movingPoints != INFINITY) && (gScore > movingPoints)) {\r\n                //log(\"(\"+neighbor.x+\",\"+neighbor.y+\") out of range\");\r\n                continue;\r\n            }\r\n\r\n            if ((!beenVisited) || (gScore < neighbor.g)) {\r\n\r\n                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n                neighbor.visited = true;\r\n                neighbor.preNodes.length = 0;\r\n                neighbor.preNodes.push(curNode);\r\n                neighbor.h = neighbor.h || neighbor.heuristic(end, astarHeuristicMode, start);\r\n                neighbor.g = gScore;\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n\r\n                // NEAREST NODE\r\n                if (isPathSearch) {\r\n                    neighbor.closerH = neighbor.h || neighbor.heuristic(end, 0);\r\n                    isNeighborMoreCloser = (neighbor.closerH < closestNode.closerH) ||\r\n                        ((neighbor.closerH === closestNode.closerH) && (neighbor.g < closestNode.g));\r\n\r\n                    if (isNeighborMoreCloser) {\r\n                        closestNode = neighbor;\r\n                    }\r\n                }\r\n                // NEAREST NODE\r\n\r\n                if (!beenVisited) {\r\n                    // Pushing to heap will put it in proper place based on the 'f' value.\r\n                    gOpenHeap.push(neighbor);\r\n                    //log(\"push (\"+neighbor.x+\",\"+neighbor.y+\") \")\r\n                } else {\r\n                    // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n                    gOpenHeap.rescoreElement(neighbor);\r\n                    //log(\"reorder (\"+neighbor.x+\",\"+neighbor.y+\") \")\r\n                }\r\n            } else if (shortestPathEnable && (gScore == neighbor.g)) {\r\n                neighbor.preNodes.push(curNode);\r\n\r\n                //if (neighbor.preNodes.indexOf(curNode) == -1)                    \r\n                //    neighbor.preNodes.push(curNode);                    \r\n                //else                    \r\n                //    debugger;                 \r\n\r\n                //log(\"drop (\"+neighbor.x+\",\"+neighbor.y+\") \")                \r\n            } else {\r\n                //log(\"drop (\"+neighbor.x+\",\"+neighbor.y+\") \")       \r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    nodeManager.closestNode = (isPathSearch) ? closestNode : null;\r\n    gOpenHeap.clear();\r\n    return this;\r\n}\r\nexport default AStarSerach;"]},"metadata":{},"sourceType":"module"}