{"ast":null,"code":"import CONST from './const.js';\nimport AngleBetween from '../../utils/math/angle/Between.js';\nimport AreTileXYArrayEqual from '../utils/AreTileXYArrayEqual.js';\nconst INFINITY = CONST.INFINITY;\nconst LINEOFFSET = 0.001;\n\nvar IsInLOS = function (chess, visiblePoints, originTileXY) {\n  // chess: chess object or tileXY\n  if (visiblePoints !== INFINITY && visiblePoints <= 0) {\n    return false;\n  }\n\n  var board = this.board;\n  var targetTileXY = board.chessToTileXYZ(chess);\n\n  if (!this.isInCone(targetTileXY)) {\n    return false;\n  }\n\n  if (originTileXY === undefined) {\n    originTileXY = this.chessData.tileXYZ;\n  }\n\n  if (this.debugLog) {\n    console.log('Visible test from (' + originTileXY.x + ',' + originTileXY.y + ') to (' + targetTileXY.x + ',' + targetTileXY.y + ')');\n  }\n\n  var out = board.tileXYToWorldXY(originTileXY.x, originTileXY.y, true);\n  var startX = out.x,\n      startY = out.y;\n  out = board.tileXYToWorldXY(targetTileXY.x, targetTileXY.y, true);\n  var endX = out.x,\n      endY = out.y;\n  var lineAngle = AngleBetween(startX, startY, endX, endY),\n      offsetX,\n      offsetY,\n      isVisivle; // Shift a small distance\n\n  lineAngle += Math.PI / 2;\n  offsetX = LINEOFFSET * Math.cos(lineAngle);\n  offsetY = LINEOFFSET * Math.sin(lineAngle);\n  var x0 = startX + offsetX,\n      y0 = startY + offsetY,\n      x1 = endX + offsetX,\n      y1 = endY + offsetY;\n  board.lineToTileXYArray(x0, y0, x1, y1, globTileXYArray0);\n\n  if (this.debugLog) {\n    console.log('Line 0: ' + JSON.stringify(globTileXYArray0));\n  }\n\n  isVisivle = this.isPathVisible(globTileXYArray0, visiblePoints);\n\n  if (isVisivle) {\n    globTileXYArray0.length = 0;\n    drawLine(this.debugGraphics, this.debugVisibleLineColor, startX, startY, endX, endY);\n    return true;\n  } // Shift a small distance\n\n\n  lineAngle += Math.PI;\n  offsetX = LINEOFFSET * Math.cos(lineAngle);\n  offsetY = LINEOFFSET * Math.sin(lineAngle);\n  var x0 = startX + offsetX,\n      y0 = startY + offsetY,\n      x1 = endX + offsetX,\n      y1 = endY + offsetY;\n  board.lineToTileXYArray(x0, y0, x1, y1, globTileXYArray1);\n\n  if (this.debugLog) {\n    console.log('Line 1: ' + JSON.stringify(globTileXYArray1));\n  } // No need do visible checking if path is the same as previous one\n\n\n  if (!AreTileXYArrayEqual(globTileXYArray0, globTileXYArray1)) {\n    isVisivle = this.isPathVisible(globTileXYArray1, visiblePoints);\n  }\n\n  globTileXYArray0.length = 0;\n  globTileXYArray1.length = 0;\n  drawLine(this.debugGraphics, isVisivle ? this.debugVisibleLineColor : this.debugInvisibleLineColor, startX, startY, endX, endY);\n  return isVisivle;\n};\n\nvar drawLine = function (graphics, color, startX, startY, endX, endY) {\n  if (graphics && color !== undefined) {\n    graphics.lineStyle(1, color, 1).lineBetween(startX, startY, endX, endY);\n  }\n};\n\nvar globTileXYArray0 = [],\n    globTileXYArray1 = [];\nexport default IsInLOS;","map":{"version":3,"sources":["C:/Users/kmode/Documents/ProjektyFullStack/war-of-champions/frontend/node_modules/phaser3-rex-plugins/plugins/board/fieldofview/IsInLOS.js"],"names":["CONST","AngleBetween","AreTileXYArrayEqual","INFINITY","LINEOFFSET","IsInLOS","chess","visiblePoints","originTileXY","board","targetTileXY","chessToTileXYZ","isInCone","undefined","chessData","tileXYZ","debugLog","console","log","x","y","out","tileXYToWorldXY","startX","startY","endX","endY","lineAngle","offsetX","offsetY","isVisivle","Math","PI","cos","sin","x0","y0","x1","y1","lineToTileXYArray","globTileXYArray0","JSON","stringify","isPathVisible","length","drawLine","debugGraphics","debugVisibleLineColor","globTileXYArray1","debugInvisibleLineColor","graphics","color","lineStyle","lineBetween"],"mappings":"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","sourcesContent":["import CONST from './const.js';\r\nimport AngleBetween from '../../utils/math/angle/Between.js';\r\nimport AreTileXYArrayEqual from '../utils/AreTileXYArrayEqual.js';\r\n\r\nconst INFINITY = CONST.INFINITY;\r\nconst LINEOFFSET = 0.001;\r\n\r\nvar IsInLOS = function (chess, visiblePoints, originTileXY) {\r\n    // chess: chess object or tileXY\r\n    if ((visiblePoints !== INFINITY) && (visiblePoints <= 0)) {\r\n        return false;\r\n    }\r\n\r\n    var board = this.board;\r\n    var targetTileXY = board.chessToTileXYZ(chess);\r\n    if (!this.isInCone(targetTileXY)) {\r\n        return false;\r\n    }\r\n\r\n    if (originTileXY === undefined) {\r\n        originTileXY = this.chessData.tileXYZ;\r\n    }\r\n    if (this.debugLog) {\r\n        console.log('Visible test from (' + originTileXY.x + ',' + originTileXY.y + ') to (' + targetTileXY.x + ',' + targetTileXY.y + ')');\r\n    }\r\n\r\n    var out = board.tileXYToWorldXY(originTileXY.x, originTileXY.y, true);\r\n    var startX = out.x,\r\n        startY = out.y;\r\n    out = board.tileXYToWorldXY(targetTileXY.x, targetTileXY.y, true);\r\n    var endX = out.x,\r\n        endY = out.y;\r\n    var lineAngle = AngleBetween(startX, startY, endX, endY),\r\n        offsetX, offsetY, isVisivle;\r\n\r\n    // Shift a small distance\r\n    lineAngle += (Math.PI / 2);\r\n    offsetX = LINEOFFSET * Math.cos(lineAngle);\r\n    offsetY = LINEOFFSET * Math.sin(lineAngle);\r\n    var x0 = startX + offsetX,\r\n        y0 = startY + offsetY,\r\n        x1 = endX + offsetX,\r\n        y1 = endY + offsetY;\r\n    board.lineToTileXYArray(x0, y0, x1, y1, globTileXYArray0);\r\n    if (this.debugLog) {\r\n        console.log('Line 0: ' + JSON.stringify(globTileXYArray0));\r\n    }\r\n    isVisivle = this.isPathVisible(globTileXYArray0, visiblePoints);\r\n    if (isVisivle) {\r\n        globTileXYArray0.length = 0;\r\n        drawLine(\r\n            this.debugGraphics,\r\n            this.debugVisibleLineColor,\r\n            startX, startY, endX, endY\r\n        );\r\n        return true;\r\n    }\r\n\r\n    // Shift a small distance\r\n    lineAngle += Math.PI;\r\n    offsetX = LINEOFFSET * Math.cos(lineAngle);\r\n    offsetY = LINEOFFSET * Math.sin(lineAngle);\r\n    var x0 = startX + offsetX,\r\n        y0 = startY + offsetY,\r\n        x1 = endX + offsetX,\r\n        y1 = endY + offsetY;\r\n    board.lineToTileXYArray(x0, y0, x1, y1, globTileXYArray1);\r\n    if (this.debugLog) {\r\n        console.log('Line 1: ' + JSON.stringify(globTileXYArray1));\r\n    }\r\n    // No need do visible checking if path is the same as previous one\r\n    if (!AreTileXYArrayEqual(globTileXYArray0, globTileXYArray1)) {\r\n        isVisivle = this.isPathVisible(globTileXYArray1, visiblePoints);\r\n    }\r\n    globTileXYArray0.length = 0;\r\n    globTileXYArray1.length = 0;\r\n    drawLine(\r\n        this.debugGraphics,\r\n        ((isVisivle) ? this.debugVisibleLineColor : this.debugInvisibleLineColor),\r\n        startX, startY, endX, endY\r\n    );\r\n    return isVisivle;\r\n}\r\n\r\nvar drawLine = function (graphics, color, startX, startY, endX, endY) {\r\n    if (graphics && (color !== undefined)) {\r\n        graphics.lineStyle(1, color, 1).lineBetween(startX, startY, endX, endY);\r\n    }\r\n}\r\n\r\nvar globTileXYArray0 = [],\r\n    globTileXYArray1 = [];\r\nexport default IsInLOS;"]},"metadata":{},"sourceType":"module"}